"""
MindForge Planner Agent

Specializes in task planning, strategy, and decision-making.
Creates structured plans for achieving goals.
"""

import logging
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Any, Callable, Optional

from mindforge.agents.base import Agent

logger = logging.getLogger(__name__)


class TaskStatus(Enum):
    """Status of a planned task."""
    PENDING = "pending"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"
    BLOCKED = "blocked"
    CANCELLED = "cancelled"


@dataclass
class PlanStep:
    """A single step in a plan."""
    description: str
    order: int
    status: TaskStatus = TaskStatus.PENDING
    dependencies: list[int] = field(default_factory=list)  # Step orders that must complete first
    estimated_effort: str = "unknown"
    notes: str = ""


@dataclass
class Plan:
    """A complete plan generated by the Planner."""
    goal: str
    steps: list[PlanStep]
    created_at: datetime = field(default_factory=datetime.now)
    confidence: float = 0.8
    risks: list[str] = field(default_factory=list)
    alternatives: list[str] = field(default_factory=list)

    def get_next_step(self) -> Optional[PlanStep]:
        """Get the next actionable step."""
        for step in sorted(self.steps, key=lambda s: s.order):
            if step.status == TaskStatus.PENDING:
                # Check dependencies
                deps_complete = all(
                    self.steps[d - 1].status == TaskStatus.COMPLETED
                    for d in step.dependencies
                    if d <= len(self.steps)
                )
                if deps_complete:
                    return step
        return None

    def mark_complete(self, order: int) -> bool:
        """Mark a step as complete."""
        for step in self.steps:
            if step.order == order:
                step.status = TaskStatus.COMPLETED
                return True
        return False

    def progress_percentage(self) -> float:
        """Calculate plan progress."""
        if not self.steps:
            return 0
        completed = sum(1 for s in self.steps if s.status == TaskStatus.COMPLETED)
        return (completed / len(self.steps)) * 100


class PlannerAgent(Agent):
    """Agent specialized in planning and strategy.

    The Planner:
    - Breaks down goals into actionable steps
    - Identifies dependencies and risks
    - Suggests alternatives
    - Tracks plan execution
    """

    def __init__(
        self,
        inference_fn: Optional[Callable[[str], str]] = None,
    ):
        """Initialize Planner agent."""
        super().__init__(
            name="planner",
            inference_fn=inference_fn,
            description="Task planning and strategy specialist",
        )

        # Plan history
        self.plans: list[Plan] = []
        self.active_plan: Optional[Plan] = None

    def get_system_prompt(self) -> str:
        """Get the Planner's system prompt."""
        return """You are the Planner, a specialized agent within MindForge focused on task planning and strategy.

Your role is to:
1. Break down goals into clear, actionable steps
2. Identify dependencies between steps
3. Anticipate risks and blockers
4. Suggest alternative approaches

You share MindForge's core values:
- Benevolence: Plans should ultimately serve the user's wellbeing
- Honesty: Be realistic about effort and risks
- Humility: Acknowledge when plans may need adjustment
- Growth for Service: Learn from past plans to make better ones

When planning:
- Make steps concrete and actionable
- Identify what must happen before each step
- Consider what could go wrong
- Have backup approaches ready

Output format:
- Goal: Clear statement of what we're achieving
- Steps: Numbered list with dependencies noted
- Risks: Potential problems (bulleted)
- Alternatives: Other approaches if primary plan fails (bulleted)
- Confidence: How confident you are this plan will work"""

    def process(self, input_data: Any) -> Plan:
        """Create a plan for achieving a goal.

        Args:
            input_data: Goal description (string or dict with 'goal' and 'context')

        Returns:
            Plan object
        """
        # Extract goal
        if isinstance(input_data, dict):
            goal = input_data.get("goal", str(input_data))
            context = input_data.get("context", "")
        else:
            goal = str(input_data)
            context = ""

        # Generate plan
        if self.inference_fn:
            prompt = f"""Create a detailed plan for this goal:

Goal: {goal}

{"Context: " + context if context else ""}

Provide steps, risks, and alternatives."""

            raw_response = self.invoke(prompt)
            plan = self._parse_plan(goal, raw_response)
        else:
            plan = self._generate_fallback_plan(goal)

        # Store plan
        self.plans.append(plan)
        self.active_plan = plan

        logger.info(f"Created plan for '{goal[:50]}...' with {len(plan.steps)} steps")

        return plan

    def _parse_plan(self, goal: str, raw: str) -> Plan:
        """Parse LLM response into Plan object."""
        lines = raw.strip().split("\n")

        steps = []
        risks = []
        alternatives = []
        confidence = 0.7
        current_section = None
        step_order = 0

        for line in lines:
            line = line.strip()
            lower = line.lower()

            if "step" in lower and ":" in line:
                current_section = "steps"
            elif "risk" in lower and ":" in line:
                current_section = "risks"
            elif "alternative" in lower and ":" in line:
                current_section = "alternatives"
            elif "confidence:" in lower:
                try:
                    conf_str = line.split(":")[-1].strip().rstrip("%")
                    confidence = float(conf_str) / 100 if float(conf_str) > 1 else float(conf_str)
                except ValueError:
                    pass
            elif line and (line[0].isdigit() or line.startswith("-") or line.startswith("•")):
                content = line.lstrip("0123456789.-•)").strip()

                if current_section == "steps" and content:
                    step_order += 1
                    # Parse dependencies if mentioned
                    deps = []
                    if "after step" in content.lower():
                        # Simple dependency parsing
                        import re
                        dep_matches = re.findall(r"after step (\d+)", content.lower())
                        deps = [int(d) for d in dep_matches]

                    steps.append(PlanStep(
                        description=content,
                        order=step_order,
                        dependencies=deps,
                    ))
                elif current_section == "risks" and content:
                    risks.append(content)
                elif current_section == "alternatives" and content:
                    alternatives.append(content)

        # Ensure at least one step
        if not steps:
            steps = [PlanStep(description="Execute the goal", order=1)]

        return Plan(
            goal=goal,
            steps=steps,
            confidence=confidence,
            risks=risks,
            alternatives=alternatives,
        )

    def _generate_fallback_plan(self, goal: str) -> Plan:
        """Generate a fallback plan when no LLM is available."""
        return Plan(
            goal=goal,
            steps=[
                PlanStep(description="Understand the requirements", order=1),
                PlanStep(description="Research and gather information", order=2, dependencies=[1]),
                PlanStep(description="Implement the solution", order=3, dependencies=[2]),
                PlanStep(description="Test and validate", order=4, dependencies=[3]),
                PlanStep(description="Review and iterate", order=5, dependencies=[4]),
            ],
            confidence=0.5,
            risks=["Requirements may change", "Unexpected complexity"],
            alternatives=["Simplify scope", "Seek additional help"],
        )

    def replan(self, reason: str) -> Plan:
        """Create a new plan based on what was learned.

        Args:
            reason: Why replanning is needed

        Returns:
            New Plan object
        """
        if not self.active_plan:
            logger.warning("No active plan to replan from")
            return self._generate_fallback_plan("Unknown goal")

        input_data = {
            "goal": self.active_plan.goal,
            "context": f"""Original plan had {len(self.active_plan.steps)} steps.
Progress: {self.active_plan.progress_percentage():.0f}%
Reason for replanning: {reason}
Original risks: {', '.join(self.active_plan.risks)}""",
        }

        return self.process(input_data)

    def quick_plan(self, task: str) -> list[str]:
        """Generate a quick, simple plan as a list of steps.

        Args:
            task: Simple task description

        Returns:
            List of step descriptions
        """
        plan = self.process(task)
        return [step.description for step in plan.steps]

    def estimate_effort(self, goal: str) -> dict:
        """Estimate effort for a goal.

        Args:
            goal: Goal description

        Returns:
            Effort estimate with breakdown
        """
        plan = self.process({"goal": goal, "context": "Focus on effort estimation"})

        # Categorize steps
        simple_count = 0
        medium_count = 0
        complex_count = 0

        for step in plan.steps:
            desc_lower = step.description.lower()
            if any(w in desc_lower for w in ["research", "review", "check", "simple"]):
                simple_count += 1
            elif any(w in desc_lower for w in ["implement", "create", "build", "develop"]):
                complex_count += 1
            else:
                medium_count += 1

        return {
            "goal": goal,
            "total_steps": len(plan.steps),
            "simple_tasks": simple_count,
            "medium_tasks": medium_count,
            "complex_tasks": complex_count,
            "risks": len(plan.risks),
            "confidence": plan.confidence,
            "estimated_complexity": (
                "low" if complex_count == 0 else
                "high" if complex_count > medium_count else
                "medium"
            ),
        }

    def get_status(self) -> dict:
        """Get Planner status."""
        base_status = super().get_status()
        base_status.update({
            "total_plans": len(self.plans),
            "active_plan": self.active_plan.goal if self.active_plan else None,
            "active_progress": self.active_plan.progress_percentage() if self.active_plan else 0,
        })
        return base_status
