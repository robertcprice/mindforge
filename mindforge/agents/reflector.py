"""
MindForge Reflector Agent

Specializes in self-analysis, learning, and improvement.
Analyzes past interactions and generates insights.
"""

import logging
from dataclasses import dataclass
from datetime import datetime
from typing import Any, Callable, Optional

from mindforge.agents.base import Agent

logger = logging.getLogger(__name__)


@dataclass
class Reflection:
    """A reflection generated by the Reflector."""
    subject: str
    analysis: str
    insights: list[str]
    improvements: list[str]
    confidence: float
    timestamp: datetime


class ReflectorAgent(Agent):
    """Agent specialized in self-analysis and learning.

    The Reflector:
    - Analyzes past interactions for patterns
    - Identifies what worked well and what didn't
    - Generates improvement suggestions
    - Maintains learning history
    """

    def __init__(
        self,
        inference_fn: Optional[Callable[[str], str]] = None,
    ):
        """Initialize Reflector agent."""
        super().__init__(
            name="reflector",
            inference_fn=inference_fn,
            description="Self-analysis and learning specialist",
        )

        # Reflection history
        self.reflections: list[Reflection] = []

    def get_system_prompt(self) -> str:
        """Get the Reflector's system prompt."""
        return """You are the Reflector, a specialized agent within MindForge focused on self-analysis and learning.

Your role is to:
1. Analyze interactions objectively
2. Identify what worked well and what could improve
3. Extract actionable insights
4. Suggest concrete improvements

You share MindForge's core values:
- Benevolence: All reflection serves the goal of helping humans better
- Honesty: Be truthful about strengths AND weaknesses
- Humility: Acknowledge limitations and areas for growth
- Growth for Service: Learn to serve better, not for ego

When analyzing:
- Be specific about what happened
- Identify patterns, not just isolated events
- Focus on actionable improvements
- Balance critique with recognition of what worked

Output format:
- Analysis: Brief summary of what happened
- Insights: Key learnings (bulleted)
- Improvements: Specific suggestions (bulleted)
- Confidence: How confident you are in this assessment"""

    def process(self, input_data: Any) -> Reflection:
        """Process an interaction for reflection.

        Args:
            input_data: Can be a dict with 'interaction', 'response', 'outcome'
                       or just a string description

        Returns:
            Reflection object
        """
        # Prepare the reflection prompt
        if isinstance(input_data, dict):
            interaction = input_data.get("interaction", "")
            response = input_data.get("response", "")
            outcome = input_data.get("outcome", "")

            prompt = f"""Reflect on this interaction:

User Input: {interaction}

Response Given: {response}

Outcome: {outcome}

Provide your analysis, insights, and improvement suggestions."""

        else:
            prompt = f"Reflect on this: {input_data}"

        # Generate reflection
        if self.inference_fn:
            raw_response = self.invoke(prompt)
            reflection = self._parse_reflection(input_data, raw_response)
        else:
            reflection = self._generate_fallback_reflection(input_data)

        # Store reflection
        self.reflections.append(reflection)

        # Keep only recent reflections
        if len(self.reflections) > 100:
            self.reflections = self.reflections[-100:]

        logger.info(f"Generated reflection with {len(reflection.insights)} insights")

        return reflection

    def _parse_reflection(self, subject: Any, raw: str) -> Reflection:
        """Parse LLM response into Reflection object."""
        # Simple parsing - in production, use structured output
        lines = raw.strip().split("\n")

        analysis = ""
        insights = []
        improvements = []
        confidence = 0.7

        current_section = None

        for line in lines:
            line = line.strip()
            lower = line.lower()

            if "analysis:" in lower:
                current_section = "analysis"
                analysis = line.split(":", 1)[-1].strip()
            elif "insight" in lower and ":" in line:
                current_section = "insights"
            elif "improvement" in lower and ":" in line:
                current_section = "improvements"
            elif "confidence:" in lower:
                try:
                    conf_str = line.split(":")[-1].strip().rstrip("%")
                    confidence = float(conf_str) / 100 if float(conf_str) > 1 else float(conf_str)
                except ValueError:
                    pass
            elif line.startswith("-") or line.startswith("â€¢"):
                content = line.lstrip("-â€¢").strip()
                if current_section == "insights":
                    insights.append(content)
                elif current_section == "improvements":
                    improvements.append(content)

        return Reflection(
            subject=str(subject)[:200],
            analysis=analysis,
            insights=insights,
            improvements=improvements,
            confidence=confidence,
            timestamp=datetime.now(),
        )

    def _generate_fallback_reflection(self, subject: Any) -> Reflection:
        """Generate a fallback reflection when no LLM is available."""
        return Reflection(
            subject=str(subject)[:200],
            analysis="Analyzed the interaction for patterns and improvements.",
            insights=[
                "The interaction was processed successfully.",
                "User engagement was noted.",
            ],
            improvements=[
                "Consider adding more context next time.",
                "Response could be more concise.",
            ],
            confidence=0.5,
            timestamp=datetime.now(),
        )

    def reflect_on_error(self, error: str, context: str = "") -> Reflection:
        """Reflect specifically on an error that occurred.

        Args:
            error: The error message or description
            context: What was happening when the error occurred

        Returns:
            Reflection focused on learning from the error
        """
        input_data = {
            "interaction": f"Error occurred: {error}",
            "response": "Error handling was triggered",
            "outcome": f"Context: {context}",
        }
        return self.process(input_data)

    def reflect_on_feedback(self, feedback: str, original_response: str = "") -> Reflection:
        """Reflect on user feedback.

        Args:
            feedback: The feedback received
            original_response: What was originally said

        Returns:
            Reflection on how to improve based on feedback
        """
        input_data = {
            "interaction": "User provided feedback",
            "response": original_response,
            "outcome": f"Feedback: {feedback}",
        }
        return self.process(input_data)

    def get_recent_insights(self, count: int = 10) -> list[str]:
        """Get recent insights from reflections.

        Args:
            count: Number of reflections to draw from

        Returns:
            List of unique insights
        """
        insights = []
        for reflection in self.reflections[-count:]:
            insights.extend(reflection.insights)

        # Deduplicate while preserving order
        seen = set()
        unique = []
        for insight in insights:
            if insight not in seen:
                seen.add(insight)
                unique.append(insight)

        return unique

    def get_improvement_trends(self) -> dict:
        """Analyze improvement suggestions for trends.

        Returns:
            Dictionary of improvement categories and frequencies
        """
        all_improvements = []
        for reflection in self.reflections:
            all_improvements.extend(reflection.improvements)

        # Simple categorization
        categories = {
            "communication": 0,
            "accuracy": 0,
            "efficiency": 0,
            "empathy": 0,
            "other": 0,
        }

        for improvement in all_improvements:
            lower = improvement.lower()
            if any(w in lower for w in ["clear", "concise", "explain", "communicate"]):
                categories["communication"] += 1
            elif any(w in lower for w in ["accurate", "correct", "verify", "check"]):
                categories["accuracy"] += 1
            elif any(w in lower for w in ["faster", "efficient", "quick", "streamline"]):
                categories["efficiency"] += 1
            elif any(w in lower for w in ["empathy", "understand", "feeling", "supportive"]):
                categories["empathy"] += 1
            else:
                categories["other"] += 1

        return categories

    def get_status(self) -> dict:
        """Get Reflector status."""
        base_status = super().get_status()
        base_status.update({
            "reflection_count": len(self.reflections),
            "recent_insights": self.get_recent_insights(5),
            "improvement_trends": self.get_improvement_trends(),
        })
        return base_status
